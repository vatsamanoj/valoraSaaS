using System.Text.Json.Serialization;

namespace Valora.Api.Application.Schemas.TemplateConfig;

/// <summary>
/// Configuration for smart MongoDB projections with auto-optimization capabilities.
/// Template-driven configuration that enables automatic index creation, denormalization,
/// and query optimization based on usage patterns.
/// </summary>
public class SmartProjectionConfig
{
    /// <summary>
    /// Enable automatic optimization based on query patterns. Default is true (smart by default).
    /// </summary>
    public bool AutoOptimize { get; set; } = true;

    /// <summary>
    /// Collection-level configuration for indexes.
    /// </summary>
    public List<IndexConfig> Indexes { get; set; } = new();

    /// <summary>
    /// Configuration for denormalizing related data for faster reads.
    /// </summary>
    public List<DenormalizationConfig> Denormalizations { get; set; } = new();

    /// <summary>
    /// Time-to-live (TTL) in days for automatic document expiration. Null means no TTL.
    /// </summary>
    public int? TtlDays { get; set; }

    /// <summary>
    /// Sharding configuration for horizontal scaling.
    /// </summary>
    public ShardingConfig? Sharding { get; set; }

    /// <summary>
    /// Caching strategy configuration.
    /// </summary>
    public CacheConfig? Caching { get; set; }

    /// <summary>
    /// Aggregation pipeline configurations for common queries.
    /// </summary>
    public List<AggregationPipelineConfig> AggregationPipelines { get; set; } = new();

    /// <summary>
    /// Document validation configuration.
    /// </summary>
    public DocumentValidationConfig? Validation { get; set; }

    /// <summary>
    /// Archival strategy for old data.
    /// </summary>
    public ArchivalConfig? Archival { get; set; }

    /// <summary>
    /// Compression configuration for large fields.
    /// </summary>
    public CompressionConfig? Compression { get; set; }

    /// <summary>
    /// Query pattern tracking configuration.
    /// </summary>
    public QueryPatternConfig? QueryPatternTracking { get; set; }
}

/// <summary>
/// Configuration for a MongoDB index.
/// </summary>
public class IndexConfig
{
    /// <summary>
    /// Unique name for the index.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Fields to include in the index with their sort order (1 for ascending, -1 for descending).
    /// </summary>
    public Dictionary<string, int> Fields { get; set; } = new();

    /// <summary>
    /// Index type: Standard, Text, Hashed, Wildcard, or Compound.
    /// </summary>
    public IndexType Type { get; set; } = IndexType.Standard;

    /// <summary>
    /// Whether this is a unique index.
    /// </summary>
    public bool IsUnique { get; set; } = false;

    /// <summary>
    /// Whether this is a sparse index (only index documents with the field).
    /// </summary>
    public bool IsSparse { get; set; } = false;

    /// <summary>
    /// Partial filter expression for partial indexes.
    /// </summary>
    public string? PartialFilterExpression { get; set; }

    /// <summary>
    /// Collation settings for the index.
    /// </summary>
    public CollationConfig? Collation { get; set; }

    /// <summary>
    /// TTL expiration in seconds (for TTL indexes).
    /// </summary>
    public int? ExpireAfterSeconds { get; set; }

    /// <summary>
    /// Whether this index was auto-generated by the optimizer.
    /// </summary>
    public bool IsAutoGenerated { get; set; } = false;

    /// <summary>
    /// Query usage statistics for this index.
    /// </summary>
    public IndexUsageStats? UsageStats { get; set; }
}

/// <summary>
/// Types of MongoDB indexes.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum IndexType
{
    Standard,
    Text,
    Hashed,
    Wildcard,
    Compound
}

/// <summary>
/// Collation configuration for indexes and queries.
/// </summary>
public class CollationConfig
{
    /// <summary>
    /// Locale string (e.g., "en", "de", "fr").
    /// </summary>
    public string Locale { get; set; } = "en";

    /// <summary>
    /// Case level comparison.
    /// </summary>
    public bool CaseLevel { get; set; } = false;

    /// <summary>
    /// Case sensitivity: "upper", "lower", or "off".
    /// </summary>
    public string CaseFirst { get; set; } = "off";

    /// <summary>
    /// Strength level: 1 (primary) to 5 (identical).
    /// </summary>
    public int Strength { get; set; } = 3;

    /// <summary>
    /// Whether to ignore punctuation.
    /// </summary>
    public bool NumericOrdering { get; set; } = false;

    /// <summary>
    /// Alternate handling: "non-ignorable" or "shifted".
    /// </summary>
    public string Alternate { get; set; } = "non-ignorable";

    /// <summary>
    /// Maximum variable: "punct" or "space".
    /// </summary>
    public string MaxVariable { get; set; } = "punct";

    /// <summary>
    /// Whether to normalize text.
    /// </summary>
    public bool Normalization { get; set; } = false;

    /// <summary>
    /// Backwards sorting for second level.
    /// </summary>
    public bool Backwards { get; set; } = false;
}

/// <summary>
/// Usage statistics for an index.
/// </summary>
public class IndexUsageStats
{
    /// <summary>
    /// Number of times this index has been used for queries.
    /// </summary>
    public long QueryCount { get; set; } = 0;

    /// <summary>
    /// Last time this index was used.
    /// </summary>
    public DateTime? LastUsedAt { get; set; }

    /// <summary>
    /// Average query execution time using this index.
    /// </summary>
    public double AverageQueryTimeMs { get; set; } = 0;

    /// <summary>
    /// Number of documents scanned vs returned ratio.
    /// </summary>
    public double ScanToReturnRatio { get; set; } = 0;
}

/// <summary>
/// Configuration for denormalizing related data.
/// </summary>
public class DenormalizationConfig
{
    /// <summary>
    /// Name of the denormalization strategy.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Source collection or entity type.
    /// </summary>
    public string SourceEntity { get; set; } = string.Empty;

    /// <summary>
    /// Target field path in the document where denormalized data will be stored.
    /// </summary>
    public string TargetFieldPath { get; set; } = string.Empty;

    /// <summary>
    /// Fields to include from the source entity.
    /// </summary>
    public List<string> SourceFields { get; set; } = new();

    /// <summary>
    /// Foreign key field that links to the source entity.
    /// </summary>
    public string ForeignKeyField { get; set; } = string.Empty;

    /// <summary>
    /// Update strategy: OnWrite, OnRead, Scheduled, or EventDriven.
    /// </summary>
    public DenormalizationUpdateStrategy UpdateStrategy { get; set; } = DenormalizationUpdateStrategy.OnWrite;

    /// <summary>
    /// For Scheduled updates, the cron expression.
    /// </summary>
    public string? ScheduleCron { get; set; }

    /// <summary>
    /// Whether to embed as an array (for one-to-many relationships).
    /// </summary>
    public bool EmbedAsArray { get; set; } = false;

    /// <summary>
    /// Maximum depth for nested denormalization.
    /// </summary>
    public int MaxDepth { get; set; } = 1;
}

/// <summary>
/// Strategies for updating denormalized data.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum DenormalizationUpdateStrategy
{
    OnWrite,
    OnRead,
    Scheduled,
    EventDriven
}

/// <summary>
/// Sharding configuration for horizontal scaling.
/// </summary>
public class ShardingConfig
{
    /// <summary>
    /// Shard key field(s).
    /// </summary>
    public Dictionary<string, int> ShardKey { get; set; } = new();

    /// <summary>
    /// Whether the shard key is unique.
    /// </summary>
    public bool IsUnique { get; set; } = false;

    /// <summary>
    /// Number of initial shards.
    /// </summary>
    public int InitialShards { get; set; } = 2;

    /// <summary>
    /// Zones for data distribution.
    /// </summary>
    public List<ShardZoneConfig> Zones { get; set; } = new();
}

/// <summary>
/// Shard zone configuration for geographic or logical data distribution.
/// </summary>
public class ShardZoneConfig
{
    /// <summary>
    /// Zone name.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Shard range minimum value.
    /// </summary>
    public string Min { get; set; } = string.Empty;

    /// <summary>
    /// Shard range maximum value.
    /// </summary>
    public string Max { get; set; } = string.Empty;
}

/// <summary>
/// Caching strategy configuration.
/// </summary>
public class CacheConfig
{
    /// <summary>
    /// Enable caching for this collection.
    /// </summary>
    public bool Enabled { get; set; } = false;

    /// <summary>
    /// Cache provider: Memory, Redis, or Distributed.
    /// </summary>
    public CacheProvider Provider { get; set; } = CacheProvider.Memory;

    /// <summary>
    /// Default TTL in minutes for cached items.
    /// </summary>
    public int DefaultTtlMinutes { get; set; } = 10;

    /// <summary>
    /// Cache key patterns for different query types.
    /// </summary>
    public List<CachePatternConfig> Patterns { get; set; } = new();

    /// <summary>
    /// Fields to include in cache keys.
    /// </summary>
    public List<string> CacheKeyFields { get; set; } = new();

    /// <summary>
    /// Maximum cache size in MB (for memory cache).
    /// </summary>
    public int MaxSizeMb { get; set; } = 100;

    /// <summary>
    /// Eviction policy: LRU, LFU, or Random.
    /// </summary>
    public EvictionPolicy EvictionPolicy { get; set; } = EvictionPolicy.LRU;
}

/// <summary>
/// Cache provider options.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum CacheProvider
{
    Memory,
    Redis,
    Distributed
}

/// <summary>
/// Cache eviction policies.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum EvictionPolicy
{
    LRU,
    LFU,
    Random
}

/// <summary>
/// Cache pattern configuration for specific query types.
/// </summary>
public class CachePatternConfig
{
    /// <summary>
    /// Pattern name.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Query pattern to match (e.g., "findByStatus").
    /// </summary>
    public string QueryPattern { get; set; } = string.Empty;

    /// <summary>
    /// TTL in minutes for this pattern.
    /// </summary>
    public int TtlMinutes { get; set; } = 10;

    /// <summary>
    /// Whether to invalidate cache on write.
    /// </summary>
    public bool InvalidateOnWrite { get; set; } = true;
}

/// <summary>
/// Pre-defined aggregation pipeline configuration.
/// </summary>
public class AggregationPipelineConfig
{
    /// <summary>
    /// Pipeline name.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Description of what this pipeline does.
    /// </summary>
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// Pipeline stages in MongoDB aggregation format.
    /// </summary>
    public List<Dictionary<string, object>> Stages { get; set; } = new();

    /// <summary>
    /// Whether this pipeline is auto-generated.
    /// </summary>
    public bool IsAutoGenerated { get; set; } = false;

    /// <summary>
    /// Usage statistics.
    /// </summary>
    public PipelineUsageStats? UsageStats { get; set; }
}

/// <summary>
/// Usage statistics for aggregation pipelines.
/// </summary>
public class PipelineUsageStats
{
    /// <summary>
    /// Number of times this pipeline has been executed.
    /// </summary>
    public long ExecutionCount { get; set; } = 0;

    /// <summary>
    /// Average execution time in milliseconds.
    /// </summary>
    public double AverageExecutionTimeMs { get; set; } = 0;

    /// <summary>
    /// Last execution time.
    /// </summary>
    public DateTime? LastExecutedAt { get; set; }
}

/// <summary>
/// Document validation configuration.
/// </summary>
public class DocumentValidationConfig
{
    /// <summary>
    /// JSON Schema for document validation.
    /// </summary>
    public Dictionary<string, object>? JsonSchema { get; set; }

    /// <summary>
    /// Validation level: Off, Strict, or Moderate.
    /// </summary>
    public ValidationLevel Level { get; set; } = ValidationLevel.Strict;

    /// <summary>
    /// Validation action: Error or Warn.
    /// </summary>
    public ValidationAction Action { get; set; } = ValidationAction.Error;
}

/// <summary>
/// Validation levels.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ValidationLevel
{
    Off,
    Strict,
    Moderate
}

/// <summary>
/// Validation actions.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ValidationAction
{
    Error,
    Warn
}

/// <summary>
/// Archival configuration for old data.
/// </summary>
public class ArchivalConfig
{
    /// <summary>
    /// Enable automatic archival.
    /// </summary>
    public bool Enabled { get; set; } = false;

    /// <summary>
    /// Field to use for archival age determination.
    /// </summary>
    public string AgeField { get; set; } = "createdAt";

    /// <summary>
    /// Age in days after which documents are archived.
    /// </summary>
    public int ArchiveAfterDays { get; set; } = 365;

    /// <summary>
    /// Archive destination: ColdStorage, S3, or SeparateCollection.
    /// </summary>
    public ArchiveDestination Destination { get; set; } = ArchiveDestination.SeparateCollection;

    /// <summary>
    /// Target collection or bucket name for archived data.
    /// </summary>
    public string TargetName { get; set; } = "_Archive";

    /// <summary>
    /// Compression format for archived data.
    /// </summary>
    public ArchiveCompression Compression { get; set; } = ArchiveCompression.Gzip;

    /// <summary>
    /// Whether to delete original documents after archival.
    /// </summary>
    public bool DeleteAfterArchive { get; set; } = false;

    /// <summary>
    /// Cron schedule for archival job.
    /// </summary>
    public string Schedule { get; set; } = "0 0 * * *"; // Daily at midnight
}

/// <summary>
/// Archive destination options.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ArchiveDestination
{
    ColdStorage,
    S3,
    SeparateCollection
}

/// <summary>
/// Archive compression formats.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ArchiveCompression
{
    None,
    Gzip,
    Bzip2,
    Lz4
}

/// <summary>
/// Compression configuration for large fields.
/// </summary>
public class CompressionConfig
{
    /// <summary>
    /// Enable field compression.
    /// </summary>
    public bool Enabled { get; set; } = false;

    /// <summary>
    /// Fields to compress (supports wildcard patterns).
    /// </summary>
    public List<string> Fields { get; set; } = new();

    /// <summary>
    /// Minimum field size in bytes to trigger compression.
    /// </summary>
    public int MinSizeBytes { get; set; } = 1024;

    /// <summary>
    /// Compression algorithm.
    /// </summary>
    public CompressionAlgorithm Algorithm { get; set; } = CompressionAlgorithm.Zstd;

    /// <summary>
    /// Compression level (1-22 for zstd, 1-9 for gzip).
    /// </summary>
    public int Level { get; set; } = 3;
}

/// <summary>
/// Compression algorithms.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum CompressionAlgorithm
{
    Gzip,
    Zstd,
    Lz4,
    Snappy
}

/// <summary>
/// Query pattern tracking configuration.
/// </summary>
public class QueryPatternConfig
{
    /// <summary>
    /// Enable query pattern tracking.
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// Sample rate for tracking (0.0 to 1.0).
    /// </summary>
    public double SampleRate { get; set; } = 0.1;

    /// <summary>
    /// Maximum number of patterns to track.
    /// </summary>
    public int MaxPatterns { get; set; } = 1000;

    /// <summary>
    /// Minimum query count before considering auto-indexing.
    /// </summary>
    public int MinQueryCountForAutoIndex { get; set; } = 100;

    /// <summary>
    /// Time window in hours for pattern analysis.
    /// </summary>
    public int AnalysisWindowHours { get; set; } = 24;

    /// <summary>
    /// Whether to automatically create indexes based on patterns.
    /// </summary>
    public bool AutoCreateIndexes { get; set; } = true;

    /// <summary>
    /// Whether to automatically suggest denormalizations.
    /// </summary>
    public bool AutoSuggestDenormalizations { get; set; } = true;
}

/// <summary>
/// Represents a detected query pattern for analysis.
/// </summary>
public class DetectedQueryPattern
{
    /// <summary>
    /// Pattern hash for identification.
    /// </summary>
    public string PatternHash { get; set; } = string.Empty;

    /// <summary>
    /// Fields used in the query filter.
    /// </summary>
    public List<string> FilterFields { get; set; } = new();

    /// <summary>
    /// Fields used for sorting.
    /// </summary>
    public List<string> SortFields { get; set; } = new();

    /// <summary>
    /// Fields returned in projection.
    /// </summary>
    public List<string>? ProjectionFields { get; set; }

    /// <summary>
    /// Number of times this pattern was executed.
    /// </summary>
    public long ExecutionCount { get; set; } = 0;

    /// <summary>
    /// Average execution time in milliseconds.
    /// </summary>
    public double AverageExecutionTimeMs { get; set; } = 0;

    /// <summary>
    /// Average documents examined per query.
    /// </summary>
    public double AverageDocsExamined { get; set; } = 0;

    /// <summary>
    /// Average documents returned per query.
    /// </summary>
    public double AverageDocsReturned { get; set; } = 0;

    /// <summary>
    /// When this pattern was first detected.
    /// </summary>
    public DateTime FirstDetectedAt { get; set; }

    /// <summary>
    /// When this pattern was last seen.
    /// </summary>
    public DateTime LastSeenAt { get; set; }

    /// <summary>
    /// Suggested index for this pattern.
    /// </summary>
    public IndexConfig? SuggestedIndex { get; set; }

    /// <summary>
    /// Whether an index has been created for this pattern.
    /// </summary>
    public bool IndexCreated { get; set; } = false;
}
